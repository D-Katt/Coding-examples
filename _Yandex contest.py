# ЗАДАЧА 1.
# Даны две строки строчных латинских символов: строка J и строка S.
# Символы, входящие в строку J, — «драгоценности», входящие в строку S — «камни».
# Нужно определить, какое количество символов из S одновременно являются «драгоценностями».
# Проще говоря, нужно проверить, какое количество символов из S входит в J.
# Это разминочная задача, к которой мы размещаем готовые решения. Она очень простая
# и нужна для того, чтобы вы могли познакомиться с нашей автоматической системой
# проверки решений. Ввод и вывод осуществляется через файлы, либо через
# стандартные потоки ввода-вывода, как вам удобнее.

j = input()
s = input()

c = 0  # Переменная-счетчик количества совпадающих букв

for el in s:  # Перебираем буквы второй строки
    if el in j:  # Ищем совпадения в первой строке
        c += 1

print(c)


# ЗАДАЧА 2.
# Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.
# Желательно получить решение, работающее за линейное время и при этом проходящее
# по входному массиву только один раз.
# Формат ввода
# Первая строка входного файла содержит одно число n, n ≤ 10000.
# Каждая из следующих n строк содержит ровно одно число — очередной элемент массива.
# Формат вывода
# Выходной файл должен содержать единственное число — длину самой длинной
# последовательности единиц во входном массиве.

n = int(input())

maximum = 0  # Максимальное число единиц, идущих подряд
current = 0  # Текущее число единиц, идущих подряд

for _ in range(n):
    x = int(input())  # Считываем n чисел

    if x == 1:  # Проверяем очередное число
        current += 1
    else:
        current = 0

    if current > maximum:  # Если текущая последовательность
        # превышает максимальную - обновляем максимум
        maximum = current

print(maximum)


# ЗАДАЧА 3.
# Дан упорядоченный по неубыванию массив целых 32-разрядных чисел.
# Требуется удалить из него все повторения.
# Желательно получить решение, которое не считывает входной файл целиком
# в память, т.е., использует лишь константный объем памяти в процессе работы.
# Формат ввода
# Первая строка входного файла содержит единственное число n, n ≤ 1000000.
# На следующих n строк расположены числа — элементы массива, по одному на строку.
# Числа отсортированы по неубыванию.
# Формат вывода
# Выходной файл должен содержать следующие в порядке возрастания
# уникальные элементы входного массива.

n = int(input())

prev = None

sorted_list = []

for _ in range(n):
    cur = int(input())  # Считываем n чисел
    if cur != prev:  # Добавляем в список,
        # только если очередное число отличается от предыдущего
        sorted_list.append(cur)
        prev = cur  # Обновляем значение предыдущего числа

for num in sorted_list:
    print(num)


# ЗАДАЧА 4.
# Даны две строки, состоящие из строчных латинских букв.
# Требуется определить, являются ли эти строки анаграммами,
# т. е. отличаются ли они только порядком следования символов.
# Формат ввода
# Входной файл содержит две строки строчных латинских символов,
# каждая не длиннее 100 000 символов. Строки разделяются символом перевода строки.
# Формат вывода
# Выходной файл должен содержать единицу, если строки являются анаграммами,
# и ноль в противном случае.

from collections import defaultdict

letters = defaultdict(int)
# Ключами словаря будут буквы, значениями - их количество.

line_1 = input()
line_2 = input()

for letter in line_1:  # Для каждой буквы в 1-й строке
    # увеличиваем значение соответствующего ключа словаря на 1
    letters[letter] += 1

for letter in line_2:  # Для каждой буквы в 2-й строке
    # уменьшаем значение соответствующего ключа словаря на 1
    letters[letter] -= 1

# Если строки содержат одинаковые буквы, то значения каждого ключа словаря равно 0.
for value in letters.values():  # Перебираем значения словаря.
    if value != 0:  # При обнаружении первого значения, отличающегося от 0
        print(0)  # завершаем перебор.
        exit()

# Если не встретилось ни одного значения, отличающегося от 0,
# значит строки являются анаграммами и содержат одинаковые буквы.
print(1)


# ЗАДАЧА 5.
# Даны k отсортированных в порядке неубывания массивов неотрицательных целых чисел,
# каждое из которых не превосходит 100. Требуется построить результат их слияния:
# отсортированный в порядке неубывания массив, содержащий все элементы исходных k массивов.
# Длина каждого массива не превосходит 10 * k.
# Постарайтесь, чтобы решение работало за время k ⋅ log(k) ⋅ n,
# если считать, что входные массивы имеют длину n.
# Формат ввода
# Первая строка входного файла содержит единственное число k, k ≤ 1024.
# Каждая из следующих k строк описывает по одному массиву.
# Первое число каждой строки равняется длине соответствующего массива,
# оставшиеся числа этой строки описывают значения элементов этого же массива.
# Элементы массивов являются неотрицательными целыми числами и не превосходят 100.
# Формат вывода
# Выходной файл должен содержать отсортированный в порядке неубывания массив,
# содержащий все элементы исходных массивов.

# Создаем строку-счетчик с индексами от 0 до 100:
counter = [0] * 101

k = int(input())

for i in range(k):  # Считываем k строк.
    # Первый символ каждой строки отбрасываем.
    _, *sequence = (int(s) for s in input().split())
    for num in sequence:  # Перебираем строку и для каждого числа в ней
        # увеличиваем счетчик соответствующего элемента списка counter.
        counter[num] += 1

for i in range(101):  # В диапазоне от 0 до 100 выводим
    # преобразованный в строку индекс с пробелом, умноженные на количество
    # (значение элемента под этим индексом).
    print((str(i) + ' ') * counter[i], end='')
