# Двумерное динамическое программирование: игра с ферзём.
# Рассмотрим игру «Ферзя в угол» для двух игроков.
# В левом верхнем углу доски размером N*M находится ферзь,
# который может двигаться только вправо-вниз.
# Игроки по очереди двигают ферзя, то есть за один ход игрок
# может переместить ферзя либо по вертикали вниз,
# либо по горизонтали вправо, либо во диагонали вправо-вниз.
# Выигрывает игрок, который поставит ферзя в правый нижний угол.
# Необходимо определить, какой из игроков может выиграть в этой игре
# независимо от ходов другого игрока (имеет выигрышную стратегию).
# Будем заполнять доску знаками «+» и «-». Знак «+» будет означать,
# что данная клетка является выигрышной для ходящего с неё игрока
# (то есть если ферзь стоит в этой клетке, то игрок, который делает ход,
# может всегда выиграть), а знак «-» означает, что он проигрывает.
# Клетки последней строки, последнего столбца и диагонали,
# ведущей из правого нижнего угла необходимо отметить, как «+»,
# так как если ферзь стоит в этой клетке, то ходящий игрок может выиграть одним ходом.
# Но в правом нижнем углу необходимо поставить знак «-» — если ферзь стоит в углу,
# то тот игрок, которых должен делать ход, уже проиграл.

# Реализовать алгоритм поиска выигрышных и проигрышных позиций
# в игре с ферзём на прямоугольном поле M на N, где N — высота, а M — ширина поля.


def chess_field(width, height):
    """Функция принимает две переменные: ширину и высоту игрового поля.
    Возвращает двумерный массив, в котором "+" обозначены выигрышные клетки и
    "-" обозначены проигрышные клетки."""

    field = [["?" for _ in range(width)] for _ in range(height)]  # создаем двумерный массив

    for i in range(height):
        field[i][width-1] = "+"  # Заполняем "+" крайний правый столбец,
        # т.к. из любой его точки можно попасть в последнюю клетку за 1 ход.
    for i in range(width):
        field[height-1][i] = "+"  # Заполняем "+" нижний ряд.

    if width < height:  # Поправка для случаев, когда ширина и высота игрового поля не совпадают.
        spred = height - width
        for i in range(spred, height):
            field[i][i - spred] = "+"  # Заполняем "+" диагональ, идущую в правую нижнюю клетку.
    else:
        spred = width - height
        for i in range(spred, width):
            field[i - spred][i] = "+"

    field[height-1][width-1] = "-"  # правая нижняя клетка проигрышная, т.к. игра уже закончена
    field[height-1][width-2] = field[height-2][width-1] = "+"  # Эти клетки всегда выигрышные.

    for i in range(-2, -height - 1, -1):  # Перебираем элементы массива в обратном порядке от конца каждой
        for j in range(-2, -width - 1, -1):  # строки к ее началу, начиная с предпоследней строки.
            if field[i][j] != "?":  # Если клетка уже заполнена, запускаем следующий цикл.
                continue
            else:  # Если клетка не заполнена,
                pos_w = j
                pos_h = i
                while pos_w < -2:
                    pos_w += 1
                    if field[pos_h][pos_w] == "-":  # Ищем "-" от текущей позиции вправо до конца строки.
                        field[i][j] = "+"
                        break
                pos_w = j  # Возвращаем значение pos_w к значению j текущей клетки.
                while pos_h < -2:
                    pos_h += 1
                    if field[pos_h][pos_w] == "-":  # Ищем "-" от текущей позиции вниз до конца столбца.
                        field[i][j] = "+"
                        break
                pos_w = j  # Возвращаем значения pos_w и pos_h к значениям i и j текущей клетки.
                pos_h = i
                while pos_w < -2 and pos_h < -2:
                    pos_w += 1
                    pos_h += 1
                    if field[pos_h][pos_w] == "-":  # Ищем "-" от текущей позиции по диагонали.
                        field[i][j] = "+"
                        break
            if field[i][j] == "?":  # Если после перебора клетка пуста, значит, она проигрышная.
                field[i][j] = "-"
    return field


field = chess_field(8, 8)  # Вызываем функцию для поля 8 х 8 клеток

for row in field:  # Выводим полученный массив
    for position in row:
        print(position, end=" ")
    print()
