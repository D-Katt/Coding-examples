# Дана таблица, состоящая из N строк и M столбцов.
# В каждой клетке таблицы записано одно из чисел: 0 или 1.
# Расстоянием между клетками (x1, y1) и (x2, y2) назовем сумму |x1-x2|+|y1-y2|.
# Вам необходимо построить таблицу, в клетке (i, j) которой будет записано
# минимальное расстояние между клеткой (i, j) начальной таблицы и клеткой,
# в которой записана 1. Гарантируется, что хотя бы одна 1 в таблице есть.
# В первой строке вводятся два натуральных числа N и M, не превосходящих 500.
# Далее идут N строк по M чисел - элементы таблицы.
# Требуется вывести N строк по M чисел - элементы искомой таблицы.

from collections import deque

n, m = (int(s) for s in input().split())  # Число строк и столбцов в таблице.

table = [0] * n  # Исходная таблица, содержащая значения 0 и 1.

for i in range(n):  # Считываем строки исходной таблицы.
    table[i] = [int(s) for s in input().split()]

graph = {(i, j): [] for j in range(m) for i in range(n)}
# Создаем словарь с ключами-кортежами из номера строки и номера столбца таблицы.

moves = [(1, 0), (-1, 0), (0, 1), (0, -1), (-1, 1), (-1, -1), (1, 1), (1, -1)]
# Потенциально возможные ходы по вертикали, горизонтали и диагоналям.

for i in range(n):
    for j in range(m):
        for x, y in moves:  # Перебираем возможные ходы из каждой клетки таблицы.
            next_i = i + x
            next_j = j + y
            if 0 <= next_i < n and 0 <= next_j < m:
                # Если ход не выходит за пределы таблицы,
                # добавляем координаты этой клетки в граф.
                graph[(i, j)].append((next_i, next_j))

res_table = [[None] * m for _ in range(n)]  # Итоговая таблица расстояний.

for i in range(n):  # Перебираем все клетки таблицы.
    for j in range(m):
        if table[i][j] == 1:  # Если в текущей ячейке 1, то расстояние 0.
            res_table[i][j] = 0
            continue  # Переходим на следующий цикл.
        # Если в текущей ячейке 0, запускаем обход в ширину в поисках 1.
        visited = set()  # Множество пройденных клеток, на каждом цикле обнуляется.
        queue = deque([(i, j)])  # Создаем очередь для перебора клеток и вносим в него текущую.
        visited.add((i, j))  # Добавляем текущую клетку в множество посещенных.
        while queue:  # Пока в очереди есть элементы,
            cur_v = queue.popleft()  # берем клетку из начала очереди.
            for x, y in graph[cur_v]:  # Перебираем соседние с ней клетки.
                if (x, y) not in visited and res_table[i][j] is None:  # Для непосещенных соседних клеток
                    # и если если значение клетки [i][j] итоговой таблицы еще не заполнено:
                    if table[x][y] == 1:  # Если встречаем 1, вычисляем расстояние до этой клетки
                        res_table[i][j] = abs(i - x) + abs(j - y)  # и добавляем в итоговую таблицу.
                        break  # Переходим на следующий цикл.
                    queue.append((x, y))  # Если в клетке 0, добавляем ее в конец очереди.

for row in res_table:  # Выводим итоговую таблицу.
    for distance in row:
        print(distance, end=" ")
    print()
