# Дан невзвешенный связный граф. Вершины пронумерованы от 0.
# Трeбуется с помощью обхода в ширину найти расстояние от одной указанной вершины до другой.
# Формат входных данных
# На вход программе в первой строке подаются через пробел четыре числа: n, m, x, y.
# Число n (2 <= n <= 1000) - количество вершин в графе,
# m (1 <= m <= 20000) - количество ребер.
# x и y - начальная и конечная вершины соответственно (0 <= x,y < n).
# В следующих m строках задаются ребра, по два числа в каждой строке - номера соединенных вершин.
# Формат выходных данных
# Требуется распечатать одно число - расстояние от вершины x до вершины y.

from collections import deque

n, m, start_vertex, end_vertex = (int(s) for s in input().split())

if start_vertex == end_vertex:
    print(0)
    exit()

graph = {i: set() for i in range(n)}  # Словарь множеств для хранения графа.

for i in range(m):
    v1, v2 = map(int, input().split())  # Считываем ребро.
    graph[v1].add(v2)
    graph[v2].add(v1)

distances = [None] * n  # Массив расстояний от стартовой вершины до всех пройденных.
distances[start_vertex] = 0  # Присваиваем ей значение 0 в списке distances.

queue = deque([start_vertex])  # Создаем очередь для перебора вершин.

while queue:  # Как только queue станет пустой, выполнение цикла прекратится.
    cur_v = queue.popleft()  # Добываем из очереди первый элемент.
    for neigh_v in graph[cur_v]:  # Перебираем его соседей.
        if distances[neigh_v] is None:  # Если соседнюю вершину не посещали,
            # она имеет значение None в списке dintances.
            distances[neigh_v] = distances[cur_v] + 1  # Тогда присваиваем ей
            # значение ее предшествующей вершины + 1.
            if neigh_v == end_vertex:  # Если встретилась конечная вершина,
                print(distances[neigh_v])  # завершаем программу.
                exit()
            queue.append(neigh_v)  # Добавляем эту вершину в конец очереди.
