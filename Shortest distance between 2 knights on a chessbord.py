# Два коня. На стандартной шахматной доске (8х8) живут 2 шахматных коня: Красный и Зеленый.
# Обычно они беззаботно скачут по просторам доски, пощипывая шахматную травку,
# но сегодня особенный день: у Зеленого коня День Рождения. Зеленый конь решил
# отпраздновать это событие вместе с Красным. Но для осуществления этого прекрасного плана
# им нужно оказаться на одной клетке. Заметим, что Красный и Зеленый шахматные кони
# сильно отличаются от черного с белым: они ходят не по очереди, а одновременно,
# и если оказываются на одной клетке, никто никого не съедает.
# Сколько ходов им потребуется, чтобы насладиться праздником?
# На вход программы поступают координаты коней, записанные по стандартным шахматным правилам
# (т.е. двумя символами - маленькая латинская буква (от a до h) и цифра (от 1 до 8),
# задающие столбец и строку соответственно).
# Требуется вывести наименьшее необходимое количество ходов,
# либо число -1, если кони не могут встретиться.

from collections import deque

red_pos, green_pos = input().split()  # Координаты коней.

if red_pos == green_pos:  # Если координаты коней совпадают,
    print(0)  # завершаем программу.
    exit()

# Если кони находятся на расстоянии 1-го хода
# или любого нечетного количества ходов друг от друга,
# то они никогда не встретятся.
# Если их разделяет четное количество ходов n,
# то минимально необходимое число ходов: n // 2.
# Поэтому запускаем поиск кратчайшего расстояния
# между двумя координатами через BFS.

letters = 'abcdefgh'  # Названия столбцов
numbers = '12345678'  # Названия строк

moves = dict()  # Создаем пустой словарь из 64 ключей,
for l in letters:  # соответствующих координатам клеток (буква+цифра).
    for n in numbers:
        moves[l + n] = set()


def add_edge(v1, v2):
    """Функция добавляет ребра в словарь по ключу."""
    moves[v1].add(v2)
    moves[v2].add(v1)


for i in range(8):  # Заполняем словарь значениями в соответствии
    for j in range(8):  # с разрешенными ходами коня.
        v1 = letters[i] + numbers[j]
        if 0 <= i + 2 < 8 and 0 <= j + 1 < 8:
            v2 = letters[i + 2] + numbers[j + 1]
            add_edge(v1, v2)
        if 0 <= i - 2 < 8 and 0 <= j + 1 < 8:
            v2 = letters[i - 2] + numbers[j + 1]
            add_edge(v1, v2)
        if 0 <= i - 1 < 8 and 0 <= j + 2 < 8:
            v2 = letters[i - 1] + numbers[j + 2]
            add_edge(v1, v2)
        if 0 <= i + 1 < 8 and 0 <= j + 2 < 8:
            v2 = letters[i + 1] + numbers[j + 2]
            add_edge(v1, v2)

# За стартовую вершину принимаем координаты красного коня,
# за финишную вершину - координаты зеленого коня.

distances = {v: None for v in moves}
# Массив расстояний от позиции 1-го коня до всех клеток доски.

distances[red_pos] = 0

queue = deque([red_pos])  # Создаем очередь для перебора клеток.

while queue:
    cur_v = queue.popleft()
    for neigh_v in moves[cur_v]:  # Для всех допустимых ходов
        if distances[neigh_v] is None:  # если соседнюю клетку не посещали,
            distances[neigh_v] = distances[cur_v] + 1  # присваиваем ей
            # значение ее предшествующей клетки + 1.
            if neigh_v == green_pos:  # Если встречаем координаты второго коня,
                queue.clear()  # очищаем очередь и прерываем цикл.
                break
            queue.append(neigh_v)  # Иначе добавляем эту клетку в конец очереди.

if distances[green_pos] % 2 == 1:  # Если второй конь находится
    print(-1)  # на нечетном расстоянии от первого, они не встретятся.
else:  # В противном случае выводим половину расстояния между ними.
    print(distances[green_pos] // 2)
