# Найти в последовательности чисел непрерывную подпоследовательность с наибольшей суммой чисел.
# Числа не упорядочены, могут быть положительными, отрицательными, повторяющимися.

sequence = [int(s) for s in input().split()]  # Считываем последовательность чисел.

max_sum = sum(sequence)  # Переменная для максимальной суммы чисел рассмотренных подпоследовательностей.
# До запуска цикла присваиваем ей сумму всех чисел последовательности.

sub_array = sequence  # Переменная для хранения подпоследовательности с наибольшей суммой чисел.
# На первом этапе содержит все числа последовательности.

cycles = 1  # Количество вложенных циклов.
step = len(sequence)  # Шаг для среза списка чисел.

# Так как мы уже рассмотрели вариант, включающий все числа последовательности,
# количество итераций во внешнем цикле на 1 меньше длины этой последовательности.
for i in range(len(sequence) - 1):
    # На каждом следующем цикле увеличивается количество итераций во вложенном цикле:
    cycles += 1
    # При этом длина выполняемых срезов уменьшается на 1:
    step -= 1
    for j in range(cycles):
        cur_sequence = sequence[j:j+step]
        cur_sum = sum(cur_sequence)  # Вычисляем сумму чисел текущего среза.
        if cur_sum > max_sum:  # Если текущая сумма больше максимальной,
            max_sum = cur_sum  # обновляем максимум
            sub_array = cur_sequence  # и переменную, содержащую искомую подпоследовательность.

print('Largest sum contiguous subarray:', sub_array)  # Выводим найденную подпоследовательность.
print('Largest sum:', max_sum)
