# Герою компьютерной игры нужно перебраться от одного края экрана к другому,
# перепрыгивая по платформам. При этом при прыжке с одной платформы на соседнюю,
# у героя уходит |y2-y1| единиц энергии, где y1 и y2 – высоты,
# на которых расположены эти платформы. Кроме того, у героя есть суперприем,
# который позволяет перескочить через платформу, но на это затрачивается 3*|y3-y1|
# единиц энергии. Конечно же, энергию следует расходовать максимально экономно.
# Вам известны высоты всех платформ в порядке от левого края до правого.
# Необходимо найти, какое минимальное количество энергии потребуется герою,
# чтобы добраться с первой платформы до последней.
# Формат входных данных
# В первой строке - количество платформ (0 < n <= 30000).
# Далее на каждой из n строк записана высота, на которой расположена очередная платформа.
# Формат выходных данных
# Одно число — минимальное количество энергии,
# которую должен потратить герой на преодоление платформ.

N = int(input())
platform = int(input())

if N == 1:
    print(0)  # Если в игре одна платформа, энергозатраты = 0
    exit()
elif N == 2:
    print(abs(int(input()) - platform))  # Если в игре 2 платформы, выводим единственно возможную стоимость.
    exit()

# Если в игре больше 2 платформ, считываем значения двух оставшихся.
next_platform = int(input())
jump_platform = int(input())

# Список содержит минимальные энергозатраты для двух последних платформ (кумулятивно).
costs = [abs(next_platform - platform),
         min(abs(next_platform - platform) + abs(jump_platform - next_platform),
                                              3 * abs(jump_platform - platform))]

for i in range(N - 3):
    platform = next_platform  # Меняем значения двух первых платформ.
    next_platform = jump_platform
    jump_platform = int(input())  # Считываем значение следующей платформы.
    # Способы на нее попасть:
    possibilities = [abs(jump_platform - next_platform) + costs[-1],  # простым прыжком с предыдущей платформы
                     3 * abs(jump_platform - platform) + costs[-2]]  # двойным прыжком через платформу
    costs[0] = costs[1]  # Убираем из списка самое первое значение, переставляя на его место следующее.
    costs[1] = min(possibilities)  # Добавляем минимальную стоимость новой платформы в список.

print(costs[-1])
