# Задача: Топология сети

# Распределённая сеть Александра состоит из n вычислительных узлов, соединённых с помощью помощью
# n − 1 кабелей. Каждый кабель соединяет ровно два различных узла, при этом любые два узла
# соединены кабелем напрямую, либо через цепочку промежуточных узлов.
# Помогите Александру, сообщите, на какие различные компьютеры необходимо установить
# дополнительные жесткие диски, чтобы ненадёжность сети была минимальна.
# Александр очень переживает за сохранность данных в системе, поэтому хочет установить
# дополнительные жесткие диски на два компьютера-хранилища. Расстоянием между двумя узлами
# Александр называет минимальное количество соединений на цепочке от одного узла к другому.
# После выбора узлов для установки дополнительных хранилищ, для каждого узла сети
# Александр определяет ближайшее к нему хранилище. Ненадёжностью сети он называет
# максимальное значение этой величины по всем узлам.

# Формат ввода
# В первой строке входных данных записано одно целое число n (2 ≤ n ≤ 200000) —
# количество компьютеров в системе Александра. Далее в n − 1 строках записаны
# по два целых числа x и y (1 ≤ x, y ≤ n, x ≠ y) — номера компьютеров, соединенных кабелем.

# Формат вывода
# В единственной строке выведите номера двух различных выбранных компьютеров.
# Если существует несколько решений, удовлетворяющих условию задачи, то выведите любое из них.

# Пример 1
# Ввод	Вывод
# 3
# 1 2
# 2 3
# 3 1

# Пример 2
# Ввод	Вывод
# 6
# 1 2
# 3 2
# 2 4
# 4 5
# 4 6
# 2 4

# Решение ниже в принципе работает, но на одном из тестов превышает лимит по времени.

from collections import deque, defaultdict
from sys import maxsize

n = int(input())

graph = defaultdict(set)

for i in range(n - 1):
    v1, v2 = [int(el) for el in input().split()]
    graph[v1].add(v2)
    graph[v2].add(v1)

best_disks = (1, 2)
result = maxsize

# Перебираем все комбинации из 2 разных номеров компьютеров:
for i in range(1, n):
    for j in range(i + 1, n + 1):

        # Вычисляем расстояния от первого хранилища до остальных ПК:
        distances_i = {i: 0, j: 0}
        queue = deque([i])
        while queue:
            cur_v = queue.popleft()
            for neigh_v in graph[cur_v]:
                if neigh_v not in distances_i:
                    distances_i[neigh_v] = distances_i[cur_v] + 1
                    queue.append(neigh_v)

        # Вычисляем расстояния от второго хранилища до остальных ПК:
        distances_j = {i: 0, j: 0}
        queue = deque([j])
        while queue:
            cur_v = queue.popleft()
            for neigh_v in graph[cur_v]:
                if neigh_v not in distances_j:
                    distances_j[neigh_v] = distances_j[cur_v] + 1
                    queue.append(neigh_v)
                    # Улучшаем кратчайшие расстояния предыдущего списка:
                    if neigh_v in distances_i:
                        if distances_j[neigh_v] < distances_i[neigh_v]:
                            distances_i[neigh_v] = distances_j[neigh_v]
                    else:
                        distances_i[neigh_v] = distances_j[neigh_v]

        max_distance = max(distances_i.values())
        if max_distance < result:
            result = max_distance
            best_disks = (i, j)

print(best_disks[0], best_disks[1])
