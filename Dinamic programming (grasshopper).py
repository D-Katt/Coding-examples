# ЗАДАЧА 1. Кузнечик может прыгать только вперед: на 1 или на 2 клеточки.
# Сколько способов существует у кузнечика попасть из клетки 1 в клетку N?


# В списке k в данном случае последний элемент - не значащий ноль.
# Фактически функция возвращает предпоследний элемент списка k.
# Первый ноль также не значащий, он нужен только для вычисления второй клетки
# по формуле, отсылающей к i - 2.
def trajectories_1_2(n):
    k = [0, 1] + [0] * n  # Создаем список, который будет хранить количество способов
    # попасть в каждую следующую клетку и заполняем его динамически по аналогии
    # с рядом чисел Фибоначчи. 0 способов попасть в клетку с индексом 0, 1 способ - в 1,
    # 1 способ - в 2, 2 - в 3 и т.д.
    for i in range(2, n + 1):
        k[i] = k[i-2] + k[i-1]
    return k[n]


print(trajectories_1_2(7))


# ЗАДАЧА 2. Решите задачу о количестве способов достичь точки n из точки 1,
# если кузнечик умеет прыгать +1, +2 и +3.


def trajectories_1_2_3(n):
    k = [0, 1, 1] + [0] * n  # Задаем значения первых трех элементов списка k.
    for i in range(3, n + 1):
        k[i] = k[i-3] + k[i-2] + k[i-1]  # Остальные вычисляем.
    print(k)
    return k[n]


print(trajectories_1_2_3(7))


# ЗАДАЧА 3. Решите задачу о количестве способов достичь точки n
# из точки 1, если кузнечик умеет прыгать +1, +2 и *3.


def trajectories_1_2_mltpl(n):
    k = [0, 1, 1] + [0] * n
    for i in range(3, n + 1):
        if i % 3 == 0:
            k[i] = k[i-2] + k[i-1] + k[i//3]
        else:
            k[i] = k[i - 2] + k[i - 1]
    print(k)
    return k[n]


print(trajectories_1_2_mltpl(10))



# ЗАДАЧА 4. В клетки с индексами 4 и 7 наступать нельзя.
# Кузнечик может прыгать на 1, 2 или 3 клетки вперед за один раз.


def trajectories2(n, allowed:list):  # allowed - список разрешенных и запрещенных клеток
    # в виде переменных типа bool (содержит True - для разрешенных клетов и False - для запрещенных).
    k = [0, 1, int(allowed[2])] + [0] * (n - 3)  # В списке True преобразуется в 1, False - в 0.
    for i in range(3, n + 1):
        if allowed[i]:  # Для клеток со значением 0 (False) операция не выполняется.
            k[i] = k[i-3] + k[i-2] + k[i-1]
    return k[n]


# ЗАДАЧА 5. Требуется вычислить минимальную стоимость достижения заданной клетки.
# price[i] - стоимость прыжка на точку i.
# C[i] - минимально возможная суммарная стоимость достижения клетки i.
# Кузнечик прыгает на 1 или 2 клетки вперед.


def min_cost(n, price: list):
    C = [float("-inf"), price[1], price[1] + price[2]] + [0] * (n - 2)
    # float("-inf") - это минус бесконечность.
    for i in range(3, n + 1):
        C[i] = price[i] + min(C[i-1], C[i-2])  # Стоимость текущей клетки
        # суммируется с минимальной стоимостью из двух предыдущих клеток.
    return C[n]


price = [0, 1, 2, 1, 1, 2, 3, 1, 2, 1, 1, 2, 1]

x = min_cost(5, price)
print(x)


# ЗАДАЧА 6. По списку С, где записана минимальная стоимость маршрута
# для всех точек от 1 до n восстановить маршрут минимальной стоимости.


def min_cost_path(n, price: list):
    C = [float("-inf"), price[1], price[1] + price[2]] + [0] * (n - 2)
    for i in range(3, n + 1):
        C[i] = price[i] + min(C[i-1], C[i-2])  # Стоимость текущей клетки
        # суммируется с минимальной стоимостью из двух предыдущих клеток.
    path = [n]  # Восстанавливаем маршрут с конца. Добавляем в него конечную точку.
    pos = n  # Запоминаем ее значение в переменной pos.
    while pos >= 3:
        if C[pos-1] < C[pos-2]:  # Выбираем наименьшее значение из двух предыдущих клеток.
            pos -= 1  # Соответствующим образом изменяем переменную pos.
            path.append(pos)  # Добавляем эту точку в маршрут.
        else:
            pos -= 2
            path.append(pos)
    if pos == 2:  # Если по итогам всех циклов начало пути (точка 1) не достигнута, добавляем ее.
        path.append(1)
    end = len(path)
    middle = end // 2
    for i in range(middle):  # Обращаем список path.
        path[i], path[end-1-i] = path[end-1-i], path[i]
    return path


price = [0, 1, 2, 1, 1, 2, 3, 1, 2, 1, 1, 2, 1]

x = min_cost_path(5, price)
print(x)


# ЗАДАЧА 7. Модифицируйте алгоритм вычисления значений целевой функции так,
# чтобы восстановить траекторию наименьшей стоимости из точки 1 в точку n.


def min_cost_path_direct(n, price: list):
    C = [float("-inf"), price[1], price[1] + price[2]] + [0] * (n - 2)
    for i in range(3, n + 1):
        C[i] = price[i] + min(C[i-1], C[i-2])
    path = [1]  # Добавляем в маршрут точку 1
    pos = 1  # Присваиваем переменной pos значение 1
    while pos < n - 2:
        if C[pos+1] <= C[pos+2]:  # Выбираем наиболее дешевую из двух следующих клеток
            pos += 1  # Соответствующим образом изменяем переменную pos.
            path.append(pos)  # Добавляем эту клетку в маршрут
        else:
            pos += 2
            path.append(pos)
    path.append(n)  # Добавляем в маршрут конечную точку, т.к. к этому моменту n - pos <= 2
    return path


price = [0, 1, 2, 1, 1, 2, 3, 1, 2, 1, 1, 2, 1]

x = min_cost_path_direct(6, price)
print(x)
