# Построить остовное дерево обходом в ширину.
# Дан невзвешенный неориентированный связный граф. Вершины пронумерованы от 0.
# Трeбуется с помощью обхода в ширину построить остовное дерево.
# На вход программе в первой строке подаются через пробел два числа:
# n (2 <= n <= 1000) — число вершин в графе.
# m (1 <= m <= 20000) — число рёбер.
# В следующих m строках задаются ребра: по два числа в каждой строке — номера соединённых вершин.
# Формат выходных данных: требуется распечатать n-1 пару чисел,
# каждyю на новой строке. Каждая пара задаёт ребро в остовном дереве.

from collections import deque

n, m = (int(s) for s in input().split())  # Число вершин и ребер в графе.

graph = {i: set() for i in range(n)}  # Создаем словарь по числу вершин.

for i in range(m):  # Считываем ребра в графе.
    a, b = (int(s) for s in input().split())
    graph[a].add(b)
    graph[b].add(a)

distances = [None] * n  # Массив расстояний от стартовой вершины до всех пройденных.
start_vertex = 0  # Стартовая вершина.
distances[0] = 0  # Присваиваем ей значение 0 в списке distances.
queue = deque([0])  # Создаем очередь для перебора вершин.
tree = []  # Список для хранения ребер остовного дерева.

while queue:  # Как только queue станет пустой, выполнение цикла прекратится.
    cur_v = queue.popleft()  # Добываем из очереди первый элемент.
    for neigh_v in graph[cur_v]:  # Перебираем его соседей.
        if distances[neigh_v] is None:  # Если соседнюю вершину не посещали,
            # она имеет значение None в списке distances.
            distances[neigh_v] = distances[cur_v] + 1  # Тогда присваиваем ей
            # значение ее предшествующей вершины + 1.
            tree.append((cur_v, neigh_v))  # Добавляем в остовное дерево ребро.
            queue.append(neigh_v)  # Добавляем эту вершину в конец очереди.

for v1, v2 in tree:  # Выводим все пары вершин остовного дерева по одной паре на строку.
    print(v1, v2)
