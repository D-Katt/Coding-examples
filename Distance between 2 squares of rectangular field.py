# Поиск расстояния на прямоугольном поле
# Дано прямоугольное поле размера n строк на m столбцов. Некоторые ячейки поля непроходимы.
# Требуется найти расстояние между двумя заданными ячейками.
# Формат входных данных
# В первой строке два числа — n и m (1 <= n, m <= 500)
# Во второй — номер строки и столбца начальной ячейки,
# в третьей — номер строки и столбца конечной ячейки.
# В остальных n строках задано поле.
# Каждая строка поля содержит m символов,
# X задает непроходимую ячейку, «пробел» — проходимую.
# Формат выходных данных
# Вывести одно число — расстояние между указанными ячейками
# (ходить можно только по горизонтали или вертикали).
# Если пути между этими ячейками нет, выведите "INF" без кавычек.

from collections import deque

n, m = (int(s) for s in input().split())  # Кол-во строк и столбцов в таблице

x1, y1 = (int(s) for s in input().split())  # Координаты первой клетки

x2, y2 = (int(s) for s in input().split())  # Координаты второй клетки

if x1 < 0 or x2 < 0 or x1 >= n or x2 >= n:  # Если координаты за пределами поля,
    print("INF")  # завершаем программу.
    exit()

if y1 < 0 or y2 < 0 or y1 >= m or y2 >= m:
    print("INF")
    exit()

if x1 == x2 and y1 == y2:  # Если начальная и конечная точки совпадают,
    print(0)  # завершаем программу.
    exit()

table = [[True] * m for _ in range(n)]  # Таблица m столбцов x n строк
# для хранения данных о непроходимых клетках.

for i in range(n):
    row = input()  # Считываем последовательно все строки таблицы,
    for j in range(m):
        if row[j] == "X":  # помечаем непроходимые ячейки.
            table[i][j] = False

if not table[x1][y1] or not table[x2][y2]:
    print("INF")  # Если начальная или конечная клетка непроходимы,
    exit()  # завершаем программу.

graph = dict()

for i in range(n):
    for j in range(m):
        graph[(i, j)] = set()  # Словарь множеств для хранения графа.
        # Ключ - кортеж, включающий соответствующий номер строки и номер столбца таблицы.

moves = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # Допустимые ходы из каждой клетки.

for i in range(n):  # Для каждой клетки в границах поля m столбцов x n строк
    for j in range(m):
        v = (i, j)  # создаем ключ соответствующей вершины графа.
        if not table[i][j]:  # Если соответствующая клетка таблицы непроходима,
            del graph[v]  # удаляем эту вершину из графа
            continue  # и переходим на следующий цикл.
        for x, y in moves:  # Если клетка проходима, перебираем возможные ходы.
            next_x = i + x
            next_y = j + y
            if 0 <= next_x < n and 0 <= next_y < m:  # Если ход находится в границах поля,
                if table[next_x][next_y]:  # и соответствующая клетка проходима,
                    graph[v].add((next_x, next_y))  # то добавляем координаты
                    # этой клетки в граф в виде кортежа, включающего номер строки и номер столбца.

distances = {v: None for v in graph}  # Массив расстояний от стартовой вершины до всех пройденных.

start_vertex = (x1, y1)  # Ключ стартовой вершины.
end_vertex = (x2, y2)  # Ключ конечной вершины.

distances[start_vertex] = 0  # Присваиваем стартовой вершине значение 0 в списке distances.
queue = deque([start_vertex])  # Создаем очередь для перебора вершин.

while queue:  # Как только queue станет пустой, выполнение цикла прекратится.
    cur_v = queue.popleft()  # Добываем из очереди первый элемент.
    for neigh_v in graph[cur_v]:  # Перебираем соседние вершины.
        if distances[neigh_v] is None:  # Если соседнюю вершину не посещали,
            # она имеет значение None в списке distances.
            distances[neigh_v] = distances[cur_v] + 1  # Тогда присваиваем ей
            # значение ее предшествующей вершины + 1.
            if neigh_v == end_vertex:  # Если мы достигли координат конечной точки,
                print(distances[neigh_v])  # выводим расстояние до нее
                exit()  # и завершаем программу.
            queue.append(neigh_v)  # Иначе добавляем эту вершину в конец очереди и продолжаем перебор.

# Если мы перебрали все возможные пути из стартовой клетки
# и не встретили финишную, то она недостижима.
print("INF")
